/********************************************************************************
** auth：  gaorong
** mail：  gaoronggood@163.com
** date：  2017-03-12 21:15:27
** desc：  对于一个由0..n的所有数按升序组成的序列，我们要进行一些筛选，
		   每次我们取当前所有数字中从小到大的第奇数位个的数，并将其丢弃。
		   重复这一过程直到最后剩下一个数。请求出最后剩下的数字。
*********************************************************************************/
#include <iostream>
#include <cmath>
using namespace std;
 
//其实是一道智力题： 观察可以得出最后删除的就是2^n-1。所以只需要找出n即可
int main()
{
    int n;
    while (cin >> n)
    {
        int i = 0;
        while (pow(2, i) <= n+1)	//n+1是观察得出的
        {
            i++;
        }
        i--;
        int res = (int)pow(2, i);
 		cout << res-1 << endl;
    }
}


/*
有大神用位操作(膜拜)：链接：https://www.nowcoder.com/questionTerminal/196141ecd6eb401da3111748d30e9141
因为是从0开始，所以第一轮移走的是二进制下最右边为0的位置（从0开始的偶数位置）上的数，然后我们发现第二轮各个number的位置等于number/2，
即从number位置到number>>1位置，这时候我们依然移走二进制下最右边为0的位置（1(01) 5(101) 9(1001) ……
它们第二轮对应的位置是0， 2， 4），最后剩一个数肯定是0到n中二进制下1最多的那个数，因为它每次的位置都是奇数位置。

#include <cstdio>

int main()
{
	int n;
	while (scanf("%d", &n) != EOF){
		int b = 1;
		while (b <= n + 1){
			b <<= 1;
		}
		printf("%d\n", (b >> 1) - 1);
	}
	return 0;
}

*/